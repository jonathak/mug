(/ 1 0)
(try (/ 1 0) (finally 0))
(try (/ 1 0) (catch ArithmeticException e 0))
(require mug.cli :reload)
(try 6)
(require mug.cli :reload)
(exit)
(-main)
(require mug.cli :reload)
(-main)
(require mug.cli :reload)
(c 'mrk)
(fgh 'mrk)
(c 'mrk)
(kh 'mrk)
(type c)
(type fjhghk)
(function? c)
(clojure.test/function? c)
(clojure.test/function? jhg)
(clojure.test/fn? jhg)
(exit)
(-main)
(util/in? [ 7 8 9] 8)
(util/in? [ 7 8 9] 88)
(require mug.cli :reload)
(def function? (fn [s] 
                                 (util/in? 
                                   ["emp" "so" "pf" "v" "b" "mkt" "c" "d" "r" "g" "e" "d2e" "cc" "mov" "mvs" "vs" "tvs" "web" "i" "s" "ceo" "cff" "zc"] 
                                   s)))
(function? "c")
(function? "khgfj")
(require mug.cli :reload)
(exit)
(-main)
(require mug.cli :reload)
(exit)
(-main)
(require mug.cli :reload)
(exit)
(-main)
(require mug.cli :reload)
(exit)
(-main)
(exit)
(-main)
(require mug.app :reload)
(require 'mug.app :reload)
(require 'mug.core :reload)
(require 'mug.cli :reload)
(-main)
(require 'mug.app :reload)
(require 'mug.core :reload)
(require 'mug.cli :reload)
(-main)
(require 'mug.app :reload)
(require 'mug.core :reload)
(require 'mug.cli :reload)
(-main)
(require 'mug.app :reload)
(require 'mug.core :reload)
(require 'mug.cli :reload)
(-main)
(cff 'mrk)
(cff 'ibm)
(cff 'argx)
(util/cash-flow+ 'mrk)
(util/cash-flow+ 'argx)
(util/raw-to-clojure (util/cash-flow+ 'argx))
( 'cashflow (util/raw-to-clojure (util/cash-flow+ 'argx)))
(= [] ('cashflow (util/raw-to-clojure (util/cash-flow+ 'argx))))
(require 'mug.app :reload)
(require 'mug.core :reload)
(require 'mug.cli :reload)
(-main)
(exit)
(-main)
(exit)
(-main)
(def date (java.util.Date))
(def date (java.util.Date.))
date
(type date)
(doc java.util.Date)
(java-doc java.util.Date)
(help)
help
(dir
)
(find-doc "java.util.Date")
(exit)
java.util.Date
(new java.util.Date)
(java.util.Date.)
(type (java.util.Date.))
(.getTime (java.util.Date.))
(/ (.getTime (java.util.Date.)) 1000)
(/ (.getTime (java.util.Date.)) 1000.0)
(int (/ (.getTime (java.util.Date.)) 1000.0))
(* 30 24 60 60)
(+ (* 30 24 60 60) (int (/ (.getTime (java.util.Date.)) 1000.0)))
(require 'mug.cli :reload)
(-main)
(.getTime (java.util.Date.))
(require 'mug.cli :reload)
(-main)
(.getTime (java.util.Date))
(.getTime (java.util.Date.))
(require 'mug.cli :reload)
(-main)
(.getTime (java.util.Date.))
(exit)
(-main)
(.getTime (java.util.Date.))
(type (.getTime (java.util.Date.)))
(require 'mug.cli :reload)
(-main)
(require 'mug.cli :reload)
(-main)
(require 'mug.cli :reload)
(-main)
(require 'mug.cli :reload)
(-main)
(require 'mug.cli :reload)
(-main)
(require 'mug.cli :reload)
(-main)
(require 'mug.cli :reload)
(-main)
(require 'mug.cli :reload)
(-main)
(* 30 24 60 60 1000)
(.getTime (.java.util.Time))
(.getTime (.java.util.Time.))
(.getTime (.java.util.Date.))
(.getTime (java.util.Date.))
(-main)
(require 'mug.cli :reload)
(-main)
(exit)
(-main)
(def q ".q")
(first q)
(second q)
(third q)
(count q)
(require 'mug.cli :reload)
(-main)
(require 'mug.cli :reload)
(-main)
.w 30 40
(-main)
.w 30 40
(-main)
(deq q ['a 'b 'c 'd 'e])
(def q ['a 'b 'c 'd 'e])
q
(count q)
(def q [1 2 3 4 5])
q
(map #(+ % 1) q)
(doc doseq)
(doseq [i q] (println i))
(def f #(+ % 1))
q
f
(map f q)
(print \.)
(print \q)
(require 'mug.cli :reload)
(-main)
(require 'mug.cli :reload)
(-main)
(require 'mug.cli :reload)
(-main)
.q
(require 'mug.cli :reload)
(-main)
@*inventory*
(map first @*inventory*)
@*bag-buffer*
(require 'mug.cli :reload)
(-main)
(@*from*)
@*from*
(@*from* 'mrk)
(require 'mug.cli :reload)
(-main)
(require 'mug.cli :reload)
(-main)
(exit)
(-main)
(require 'mug.cli :reload)
(-main)
.m c
(-main)
(require 'mug.cli :reload)
(-main)
(require 'mug.cli :reload)
(-main)
(require 'mug.cli :reload)
(-main)
(exit)
(-main)
_
'_
.q
(-main)
(c 'mrk)
(c 'ba)
(dir mug.util)
(util/cash-flow+ 'mrk))
(util/cash-flow! 'mrk))
(util/cash-flow+ 'mrk)
(util/cash-flow! 'mrk)
(util/company! 'mrk)
(def base-url "https://cloud.iexapis.com/")
(def version "beta")
(def endpoint-path (str "/stock/" ticker "/company"))
(def endpoint-path (str "/stock/" 'MRK "/company"))
(def keychain (eval (read-string (slurp "resources/keychain.clj"))))
(def u (str base-url version endpoint-path query-string))
(def query-string (str "?token=" (:iexcloud keychain)))
(def u (str base-url version endpoint-path query-string))
u
(def m (try (client/get u {:cookie-policy :standard}) (catch Exception e 1)))
(require [clj-http.client :as client])
(require clj-http.client :as client)
(require 'clj-http.client :as client)
(require 'clj-http.client)
(def hm (try (clj-http.client/get u {:cookie-policy :standard}) (catch Exception e 1)))
hm
(exit)
(-main)
(c 'mrk)
(e 'mrk)
.l
(-main)
(exit)
(-main)
(exit)
(-main)
(exit)
(-main)
(zc 'seel)
(zc 'agrx)
(require 'mug.core :reload)
(zc 'agrx)
(zc 'novn)
(zc 'aqxp)
aqxp sec
(sec 'aqxp)
(exit)
(ctg 'cdtx)
(ctg 'mrk)
(ctg 'rnn)
(util.news! 'cdtx)
(require 'mug.util :reload)
(mug.util/news 'mrk)
(util/news 'cdtx)
(util.news 'cdtx)
(mug.util/news 'cdtx)
(mug.util/news! 'cdtx)
(mug.util/news! 'mrk)
(require 'mug.util :reload)
(mug.util/news! 'mrk)
(mug.util/news! 'cdtx)
(count (mug.util/news! 'cdtx))
(def q (mug.util/news! 'cdtx))
q
(type q)
(str/replace q #"\"" "")
(read-string (str/replace q #"\"" ""))
q
(read-string (str/replace q #"\"" ""))
(str/replace q #"\"" "")
(-> (str/replace q #"\"" "") (str/replace #":" " ")))
(-> (str/replace q #"\"" "") (str/replace #":" " "))
(-> (str/replace q #"\"" "") )
(-> (str/replace q #"\"" "") (str/replace #":" "@@"))
(-> (str/replace q #"\"" "") )
(-> (str/replace q #"\"" "") (str/replace #"s:/" "s@@/"))
(-> (str/replace q #"\"" "") (str/replace #"s:/" "s@@/") (str/replace #"@@" ":"))
(-> (str/replace q #"\"" "") (str/replace #"s:/" "s@@/") (str/replace #"@@" ":") (read-string))
(-> (str/replace q #"\"" "") (str/replace #"s:/" "s@@/") (str/replace #"@@" ":"))
(-> (str/replace q #"\"" "") (str/replace #"s:/" "s@@/") (str/replace #":" " ") (str/replace #"@@" ":"))
(-> (str/replace q #"\"" "") (str/replace #"s:/" "s@@/") (str/replace #":" " ") (str/replace #"@@" ":") (read-string))
(-> (str/replace q #"\"" "") (str/replace #"s:/" "s@@/") (str/replace #":" " ") (str/replace #"@@" ":"))
(require 'mug.util :reload)
(require 'mug.app :reload)
(require 'mug.core :reload)
(require 'mug.cli :reload)
(-main)
(news 'mrk)
(util/news! 'mrk)
(raw-to-clojure (util/news! 'mrk))
(app/news 'mrk)
(app/news! 'mrk)
(util/news! 'mrk)
(app/news 'mrk)
(require 'mug.app :reload)
(app/news 'mrk)
(require 'mug.app :reload)
(app/news 'mrk)
(require 'mug.app :reload)
(app/news 'mrk)
(require 'mug.app :reload)
(app/news 'mrk)
(require 'mug.app :reload)
(app/news 'mrk)
(require 'mug.app :reload)
(app/news 'mrk)
(read-string (app/news 'mrk))
(require 'mug.app :reload)
(app/news 'mrk)
(require 'mug.app :reload)
(app/news 'mrk)
(count (app/news 'mrk))
(def q (app/news 'mrk))
(type q)
(count q)
(first q)
(second q)
(require 'mug.app :reload)
(def q (app/news 'mrk))
(second q)
(first q)
(last q)
(require 'mug.app :reload)
(def q (app/news 'mrk))
(second q)
(require 'mug.app :reload)
(def q (app/news 'mrk))
(second q)
(require 'mug.app :reload)
(def q (app/news 'mrk))
(second q)
(count (second q))
(def q '(b 'c 'd))
q
(pop q)
q
(pop (into [] q))
(require 'mug.app :reload)
(def q (app/news 'mrk))
q
(require 'mug.app :reload)
(def q (app/news 'mrk))
q
(type q)
(count q)
(first q)
(last q)
(require 'mug.app :reload)
(def q (app/news 'mrk))
(first q)
(require 'mug.app :reload)
(def q (app/news 'mrk))
(first q)
(require 'mug.app :reload)
(def q (app/news 'mrk))
(first q)
(require 'mug.app :reload)
(def q (app/news 'mrk))
(first q)
(require 'mug.app :reload)
(def q (app/news 'mrk))
(first q)
(require 'mug.app :reload)
(def q (app/news 'mrk))
(first q)
q
(app/news 'mrk)
(require 'mug.app :reload)
(def q (app/news 'mrk))
(first q)
q
(require 'mug.app :reload)
(def q (app/news 'mrk))
(require 'mug.app :reload)
(def q (app/news 'mrk))
q
(require 'mug.app :reload)
(def q (app/news 'mrk))
q
(println q)
(require 'mug.app :reload)
(def q (app/news 'mrk))
q
(require 'mug.app :reload)
(def q (app/news 'mrk))
q
(require 'mug.app :reload)
(def q (app/news 'mrk))
q
(-main)
(exit)
(-main)
(news 'cdtx)
(require 'mug.cli :reload)
(-main)
(require 'mug.cli :reload)
(-main)
(require 'mug.app :reload)
(-main)
(require 'mug.app :reload)
(-main)
.fo
(-main)
@*inventory*
(require 'mug.cli :reload)
(dow)
(require 'mug.cli :reload)
(dow)
(require 'mug.cli :reload)
(dow)
(require 'mug.cli :reload)
(dow)
(require 'mug.cli :reload)
(dow)
(require 'mug.cli :reload)
(dow)
(require 'mug.cli :reload)
(dow)
(require 'mug.cli :reload)
(dow)
.q
@*inventory*
(exit)
(-main)
9exit)
(exit)
(-main)
(require 'mug.cli :reload)
(dow)
(exit)
(dow)
(exit)
(dow)
(exit)
(-main)
.srt
.m cff
@*inventory*
(def q @*inventory*)
q
(map first q)
(map (map first q)
))))
(map (map first q))
q
(map first q)
(map cff (map first q))
(def x (map first q))
x
(cff (first x))
(doseq [y x] y)
(doc doseq)
q
x
(doseq [xx x] (cff xx))
x
(map cname x)
(map c x)
(map cff x)
(cff 'snna)
(cff 'snes)
(cff 'lpcn)
(cff 'aktx)
(cff 'bpth)
(cff 'cldx)
x
(cff 'lptx)
(cff 'vtgn)
(cff 'innt)
(cff 'pdsb)
(cff 'mbrx)
(cff 'cfrx)
(cff 'mtp)
(cff 'oncy)
(cff 'mtp)
(cname 'mtp)
(c 'mtp)
(r 'mtp)
(cffd 'mtp)
(require 'mug.core :reload)
(require 'mug.app :reload)
(require 'mug.cli :reload)
@*inventory*
(cffd 'myp)
(cffd 'mtp)
(cff 'mtp)
(bag)
(require 'mug.core :reload)
(require 'mug.app :reload)
(require 'mug.cli :reload)
@*inventory*
(cff 'mtp)
(bag)
(exit)
